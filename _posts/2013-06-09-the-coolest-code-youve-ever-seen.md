---
layout: post
title: "我见过的最酷的代码"
description: ""
category: 
tags: []
---
{% include JB/setup %}
最酷的代码？第一眼看到这个问题的时候，我的脑海中就想起了这段Haskell代码
{% gist 5743536 %}
第一次是在[编程范式](http://v.163.com/special/opencourse/paradigms.html)看到这段代码. 如代码的名字表明的一样，它构建的是一个计算[斐波那契数列](http://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)的函数。第一行构建的是一个无穷长的斐波那契数列，第二行表示从数列中取出第`n`个元素。

如果之前没有接触过Haskell的话，可能还没法看出代码后面的魔法，别急，让我们开始学习一些背景知识。

* 使用 `=` 定义函数，如 `fibs` 是一个无参数的函数（特化成了一个值），`fib` 是有一个参数的函数。这里的 `=` 与数学里面的 `=` 功能是一样的。需要注意的是，参数之间不需要 `,`，参数表前后也不需要括号。

* 使用 `:` 在列表头部添加新的元素，如 `a:b` 代表在`b`（类型是`a`类型的列表）头部添加一项`a`。

* `zipWith` 是内建的一个函数，有三个参数，第一个参数是一个二元的函数，第二个和第三个参数都是列表，函数功能是生成一个新的列表，它的每一项都是参数2和参数3对应项通过参数1计算而来。如 `zipWith (+) [1, 2, 3] [2, 3, 4]` 等于 `[3, 5, 7]`。

* `tail` 也是一个内建的函数，它有一个参数，是一个列表，它返回该列表的除第一项以外的其它项。如 `tail [1, 2, 3]` 等于 `[2, 3]`。
* `!!` 还是一个内建函数，`a !! b` 功能是取出列表 `a` 的第 `b` 项（索引从 `0` 开始）。如 `[1, 2, 3] !! 2` 等于 `3`。

有了这些背景知识，再来看看那段代码吧！

第一行定义了 `fibs`， 把右边的表达式看成两部分 `1:1:` 和 `zipWith (+) fibs (tail fibs)`，`fibs`是一个以`1, 1`开始的列表

    # fibs                          (1)
    # tail fibs                     (2)
    # zipWith (+) fibs (tail fibs)  (3)
    1 1 (3)
    1 (3)
    2 (4)

把 `(3)` 用 `2 (4)` 替换，得到

    1 1 2 (4)
    1 2 (4)
    2 3 (5)

把 `(3)` 用 `2 3 (5)` 替换，得到

    1 1 2 3 ...
    1 2 3 ...
    2 3 5 ...

就这样不断执行下去，我们可以得到一个无穷长的斐波那契数列。

**无限**长，你在开玩笑吗！！！^_^，这里利用到了Haskell的一个特性，惰性求值，就是说，值会尽量晚的（被使用的时候）被求值，所以`fibs`是个理论上的无限长的列表，当使用它时，它才会把必要的一部分给计算出来，如`fib 4`, 如果它没有被计算出来的话，它就计算前5项（索引从0开始）。

怎么样？被Haskell给吸引住了吧？如果想继续学习Haskell的话，可以看看[Haskell趣学指南](http://learnyouahaskell-zh-tw.csie.org/)。
